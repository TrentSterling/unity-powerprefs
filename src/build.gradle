project.ext {
    unity_exe = System.getProperty("UNITY_EXE")
    if (unity_exe == null || unity_exe.isEmpty()) {
        unity_exe = System.getenv("UNITY_EXE")
    }
    if (unity_exe == null || unity_exe.isEmpty()) {
        unity_exe ='/Applications/Unity/Unity.app/Contents/MacOS/Unity'
    }

    src = file('PowerPrefs').absolutePath
    buildSrc = file('build/PowerPrefsSrc').absolutePath
    buildProj = file('build/PowerPrefsProj').absolutePath
    buildPath = file('build').absolutePath
    exportPath = file('build/PowerPrefs.unitypackage').absolutePath
    currentPackagePath = file('../current-build').absolutePath
    currentPackageName = 'PowerPrefs-0.1.0.unitypackage'
}

if (!tasks.findByName('prebuild')) {
    task prebuild() {
        println('Local prebuild')
    }
    prebuild.dependsOn {
        project.tasks.findAll { task -> task.ext.has('remoteTaskPhase') && task.ext.remoteTaskPhase == 'prebuild' }
    }
}
if (!tasks.findByName('build')) {
    task build() {
        println('Local build')
    }
    build.dependsOn {
        project.tasks.findAll { task -> task.ext.has('remoteTaskPhase') && task.ext.remoteTaskPhase == 'build' }
    }
}
if (!tasks.findByName('postbuild')) {
    task postbuild() {
        println('Local postbuild')
    }
    postbuild.dependsOn {
        project.tasks.findAll { task -> task.ext.has('remoteTaskPhase') && task.ext.remoteTaskPhase == 'postbuild' }
    }
}
project.defaultTasks = ['prebuild', 'build', 'postbuild']

task unity_package(dependsOn:'export_package') {

    description = "Top level task for building the unity packages"

    doLast {
        println "Packaging Complete!"
    }

    ext.remoteTaskPhase = 'build'
}

task copy_src << {
    copy {
        from {"${buildSrc}"}
        includes ["**/*"]
        duplicatesStrategy DuplicatesStrategy.INCLUDE
        into {"${buildProj}"}
    }
}
copy_src.ext.remoteTaskPhase = 'build'

task export_package () {
    description = "Creates and exports the unity package"

    doLast {
        def argv = [
                "-g.building",
                // NOTE: This doesn't target Android since we don't want to have
                // dependencies on the Jar Resolver as they require the plugin to
                // be enabled during the build process which would break the
                // versioning process.  Compilation is verified when exporting
                // the sample projects.
                "-batchmode",
                "-projectPath", "${pluginProj}",
                "-logFile", "build/unity.log",
                "-exportPackage",
                    "Assets/GooglePlayGames",
                    "Assets/PlayServicesResolver",
                    "Assets/Plugins/Android/libs",
                    "Assets/Plugins/Android/MainLibProj",
                    "Assets/Plugins/iOS",
                "${exportPath}",
                "-quit"
        ]

        ext.execResult = exec {
            executable "${unity_exe}"
                args argv
                ignoreExitValue true
        }
        if (ext.execResult.exitValue != 0) {
            println "***Error Running Unity:"
            def src = file('build/unity.log').text
            print src
            throw new GradleException('error exporting plugin')
        }
    }
}
export_package.dependsOn copy_pluginProjSrc
export_package.ext.remoteTaskPhase = 'build'

task copy_plugin() {
    description = 'Copy plugin to the current-build directory'
    doFirst {
            copy {
                from file(exportPath)
                into file(currentPluginPath)
                rename ('plugin.unitypackage', currentPluginName)
            }
        }

    doLast {
        println "Copied  ${exportPath}  to   ${currentPluginPath}"
    }

    ext.remoteTaskPhase = 'postbuild'
}


task copy_plugin_source << {
    copy {
        from {"${pluginSrc}"}
        into {"${pluginBuildSrc}"}
    }
}
copy_plugin_source.description = "Copies plugin source into build directory"
copy_plugin_source.ext.remoteTaskPhase = 'prebuild'

task clean() {
  doFirst {
    delete 'build'
  }
}
